<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>Hand Tracking - Con Logo</title>
  <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.158.0/three.min.js"></script>  
  
  <style>
    body { 
      margin:0; 
      font-family: system-ui, Arial; 
      background:#000; 
      overflow: hidden; 
    }
    
    a-scene { 
      position: absolute;
      top: 0; left: 0;
      height: 100vh; 
      width: 100vw; 
      z-index: 1; /* Fondo */
    }
    
    #videoElement { 
        display: none; 
    }

    /* Contenedor para la cámara y el logo */
    #top-left-elements {
        position: absolute;
        top: 10px;
        left: 10px;
        z-index: 10;
        display: flex; 
        align-items: center; 
        gap: 10px; 
        background: rgba(0,0,0,0.7); 
        padding: 10px; 
        border-radius: 8px; 
    }

    #overlayCanvas { 
      width: 200px;  
      height: 150px; 
      display: block !important; 
      border: 2px solid rgba(255,255,255,0.5); 
      border-radius: 8px; 
      object-fit: cover; 
    }

    #teamLogo {
        width: 100px; 
        height: auto; 
        border-radius: 8px; 
        z-index: 11; 
    }

    /* UI que solo contiene el estado */
    #ui { 
      position: absolute; 
      bottom: 0; left: 0; right: 0; 
      z-index: 20; 
      background: rgba(0,0,0,0.7); 
      color: white; 
      padding: 10px; 
      font-size: 14px;
      display: flex; 
      justify-content: center; 
      align-items: center;
      min-height: 40px; 
    }
    
  </style>
</head>
<body>
  <video id="videoElement" playsinline></video>
  
  <div id="top-left-elements">
    <canvas id="overlayCanvas"></canvas>
    
    <img id="teamLogo" src="biotec.png" alt="Logo del equipo Biotec">
  </div>

  <div id="ui">
    <div>Estado: <span id="status">Inactivo</span></div>
  </div>

  <a-scene background="color: #000"> 
    <a-assets>
      <a-asset-item id="handModel" src="hand.glb"></a-asset-item>
    </a-assets>

    <a-entity light="type: ambient; intensity: 1"></a-entity>
    <a-entity light="type: directional; intensity: 0.6" position="0 2 2"></a-entity>
    <a-entity camera position="0 0 0"></a-entity>

    <a-entity 
        id="handEntity" 
        hand-control 
        gltf-model="#handModel" 
        position="0 0 -1.0" 
        rotation="0 180 0" 
        scale="2.0 2.0 2.0">
    </a-entity>
  </a-scene>

<script>
const videoElement = document.getElementById('videoElement');
const overlay = document.getElementById('overlayCanvas');
const overlayCtx = overlay.getContext('2d');
const statusEl = document.getElementById('status');
const handEntity = document.getElementById('handEntity');

let cameraInstance = null; 
let refVectorOption = 0; 

const hands = new Hands({
  locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
});

hands.setOptions({
  maxNumHands: 1, 
  modelComplexity: 0, 
  minDetectionConfidence: 0.6, 
  minTrackingConfidence: 0.6
});
hands.onResults(onHandsResults);

function startCameraOnFirstInteraction() {
    if (cameraInstance) return;
    statusEl.textContent = 'Iniciando...';
    document.removeEventListener('click', startCameraOnFirstInteraction); 
    document.removeEventListener('touchstart', startCameraOnFirstInteraction);
    navigator.mediaDevices.getUserMedia({ video: { width: 640, height: 480 } })
        .then(stream => {
            videoElement.srcObject = stream;
            videoElement.onloadedmetadata = () => {
                videoElement.play();
                overlay.width = videoElement.videoWidth;
                overlay.height = videoElement.videoHeight;
                cameraInstance = new Camera(videoElement, {
                    onFrame: async () => { await hands.send({image: videoElement}); },
                    width: 640, height: 480
                });
                cameraInstance.start();
                statusEl.textContent = '¡Activo! (Mueve la mano)';
            };
        })
        .catch(error => {
            console.error("Error al acceder a la cámara:", error);
            statusEl.textContent = 'Error de cámara.';
        });
}
document.addEventListener('click', startCameraOnFirstInteraction);
document.addEventListener('touchstart', startCameraOnFirstInteraction);

// --- Componente de A-Frame (Posicionamiento y Animación) ---
AFRAME.registerComponent('hand-control', {
  init: function(){
    this.bones = {};
    this.basePose = {}; 
    this.invert = {x: -1, y: -1, z: -1}; 
    this.smoothFactor = 0.15; 
    this.lastLandmarks = null; 
    this.scaleFactor = 1.0;

    // === CAMBIO 68: Límites del Pulgar Sin Topes ===
    this.flexionLimits = {
        'thumb000': {min: -8.0, max: 0.2}, // Antes -5.0
        'thumb001': {min: -8.0, max: 0.2}, // Antes -5.0
        'thumb002': {min: -8.0, max: 0.2}, // Antes -5.0
        
        'index001': {min: -0.1, max: 2.5}, 'index002': {min: -0.1, max: 2.5},
        'middle001': {min: -0.1, max: 2.5}, 'middle002': {min: -0.1, max: 2.5},
        'ring001': {min: -0.1, max: 2.5}, 'ring002': {min: -0.1, max: 2.5},
        'pinky001': {min: -0.1, max: 2.5}, 'pinky002': {min: -0.1, max: 2.5},
    };
    this.abductionLimits = {
        'thumb000': {min: -0.6, max: 0.6}, 'thumb001': {min: -0.2, max: 0.2}, 'thumb002': {min: -0.2, max: 0.2},
        'index001': {min: -0.2, max: 0.2}, 'middle001': {min: -0.1, max: 0.1}, 'ring001': {min: -0.2, max: 0.2},
        'pinky001': {min: -0.25, max: 0.25}, 
    };
    
    // === CAMBIO 68: Influencia del Pulgar Aumentada ===
    this.flexionInfluence = {
        'thumb000': -1.5, 'thumb001': -1.5, 'thumb002': -1.5, // Antes -1.0
        'index001': 0.8, 'index002': 0.8,
        'middle001': 0.8, 'middle002': 0.8,
        'ring001': 0.8, 'ring002': 0.8,
        'pinky001': 0.8, 'pinky002': 0.8,
    };

    // === CAMBIO 68: ¡RESET DE CALIBRACIÓN! ===
    this.poseOffsets = {
        'thumb000': { z: 0, x: 0 }, // ¡Reseteado!
        'thumb001': { z: 0, x: 0 }, // ¡Reseteado!
        'thumb002': { z: 0, x: 0 }  // ¡Reseteado!
    };
    
    this.el.addEventListener('model-loaded', () => {
      const obj = this.el.getObject3D('mesh');
      if (!obj) { console.warn('No mesh'); return; }
     
      obj.traverse(node => { 
        if (node.isBone) {
          this.bones[node.name] = node;
          this.basePose[node.name] = node.quaternion.clone(); 

          // Aplicar Compensación UNA SOLA VEZ
          if (this.poseOffsets[node.name]) {
            const offset = this.poseOffsets[node.name];
            const offsetEuler = new THREE.Euler(
              offset.x || 0,
              offset.y || 0,
              offset.z || 0,
              'YXZ'
            );
            const qOffset = new THREE.Quaternion().setFromEuler(offsetEuler);
            this.basePose[node.name].premultiply(qOffset);
          }
        } 
      });
      this.ready = true;
    });
  },
 
  tick: function(){
    if (!this.ready || !this.lastLandmarks) return; 
    const landmarks = this.lastLandmarks;
    this.applyLandmarksToBones(landmarks);
  },

  getRefVector: function() {
      return new THREE.Vector3(0, 1, 0); 
  },

  applyLandmarksToBones: function(landmarks) {
    const { bones, basePose, invert, smoothFactor, scaleFactor, flexionLimits, abductionLimits, flexionInfluence } = this;
    const ref = this.getRefVector(); 

    const fingerMap = [
      ['thumb000', 1, 2], ['thumb001', 2, 3], ['thumb002', 3, 4],
      ['index001', 6, 7], ['index002', 7, 8],
      ['middle001', 10, 11], ['middle002', 11, 12],
      ['ring001', 14, 15], ['ring002', 15, 16],
      ['pinky001', 18, 19], ['pinky002', 19, 20]
    ];
   
    const alpha = Math.max(0.02, smoothFactor); 

    // === LÓGICA DE MUÑECA SIMPLE (ESTÁTICA) ===
    if (bones['Bone'] && landmarks[0] && landmarks[9]) {
      const v0 = new THREE.Vector3(landmarks[0].x * invert.x, landmarks[0].y * invert.y, landmarks[0].z * invert.z);
      const v9 = new THREE.Vector3(landmarks[9].x * invert.x, landmarks[9].y * invert.y, landmarks[9].z * invert.z);
      const dirW = new THREE.Vector3().subVectors(v9, v0).normalize();

      const qDeltaW = new THREE.Quaternion().setFromUnitVectors(ref, dirW);
      const influenceW = Math.min(1, scaleFactor * 0.1); 
      const qApplyW = new THREE.Quaternion().slerpQuaternions(new THREE.Quaternion(), qDeltaW, influenceW);

      const base = basePose['Bone'] || bones['Bone'].quaternion.clone();
      let desired = base.clone().multiply(qApplyW);

      bones['Bone'].quaternion.slerp(desired, alpha);
    }
    // === FIN DE LÓGICA DE MUÑECA ===


    // 2. Dedos (Lógica de animación)
    for (const [name, a, b] of fingerMap) {
      const bone = bones[name];
      if (!bone) continue;
      if (!landmarks[a] || !landmarks[b]) continue;

      const p1 = new THREE.Vector3(landmarks[a].x * invert.x, landmarks[a].y * invert.y, landmarks[a].z * invert.z);
      const p2 = new THREE.Vector3(landmarks[b].x * invert.x, landmarks[b].y * invert.y, landmarks[b].z * invert.z);
      
      let dir = new THREE.Vector3().subVectors(p2, p1); 
      if (dir.lengthSq() < 1e-6) continue;
      dir.normalize();

      const qDelta = new THREE.Quaternion().setFromUnitVectors(ref, dir);

      // ¡Invertir TODOS los dedos!
      qDelta.invert();

      const euler = new THREE.Euler().setFromQuaternion(qDelta, 'YXZ');

      let flexAxis = 'x';
      let abductAxis = 'z';

      if (name.includes('thumb')) {
          flexAxis = 'z';
          abductAxis = 'x';
      }

      const currentFlexionInfluence = flexionInfluence[name] !== undefined ? flexionInfluence[name] : 0.4;
      euler[flexAxis] *= currentFlexionInfluence; 

      if (flexionLimits[name]) {
          euler[flexAxis] = Math.max(flexionLimits[name].min, Math.min(flexionLimits[name].max, euler[flexAxis]));
      }
      if (abductionLimits[name]) {
          euler[abductAxis] = Math.max(abductionLimits[name].min, Math.min(abductionLimits[name].max, euler[abductAxis]));
      }
      
      euler.y = 0; 

      const qFinal = new THREE.Quaternion().setFromEuler(euler);
      const baseQ = basePose[name] ? basePose[name].clone() : bone.quaternion.clone(); // ¡Typo corregido!
      const desiredQ = baseQ.clone().multiply(qFinal);

      bone.quaternion.slerp(desiredQ, alpha); 
    }
  }
});


// --- Procesar Resultados de MediaPipe con Corrección de Espejo ---
function onHandsResults(results){
  overlayCtx.clearRect(0,0,overlay.width,overlay.height);
 
  // CORRECCIÓN DE ESPEJO
  overlayCtx.save();
  overlayCtx.translate(overlay.width, 0); 
  overlayCtx.scale(-1, 1); 
  overlayCtx.drawImage(results.image, 0, 0, overlay.width, overlay.height);
  overlayCtx.restore();
 
  if (results.multiHandLandmarks?.length > 0){
    const lm = results.multiHandLandmarks[0];
   
    if (videoElement.readyState >= 2) {
      for (let i=0;i<lm.length;i++){
        const x = (1 - lm[i].x) * overlay.width;
        const y = lm[i].y * overlay.height;
        overlayCtx.beginPath(); overlayCtx.arc(x,y,3,0,2*Math.PI);
        overlayCtx.fillStyle='red'; overlayCtx.fill();
      }
    }

    const comp = handEntity.components['hand-control'];
    if (comp) comp.lastLandmarks = lm.map(p=>({x:p.x, y:p.y, z:p.z}));
  } else {
    const comp = handEntity.components['hand-control'];
    if (comp) comp.lastLandmarks = null;
  }
}
</script>
</body>
</html>  
