<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Hand Tracking - Solución FINAL: Estabilidad en Posición</title>
  <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.158.0/three.min.js"></script>  
  <style>
    body { margin:0; font-family: system-ui, Arial; background:#000; }
    #videoElement { position: absolute; visibility: hidden; z-index: -1; }
    #overlayCanvas { position: absolute; left: 0; top: 0; z-index: 10; display: block !important; }
    #ui { 
      position: absolute; right: 8px; top: 8px; z-index: 20; 
      background: rgba(255,255,255,0.9); padding:8px; border-radius:6px; 
      font-size: 14px;
    }
    a-scene { height:100vh; width:100vw; display:block; }
  </style>
</head>
<body>
  <video id="videoElement" playsinline></video>
  <canvas id="overlayCanvas"></canvas>

  <div id="ui">
    <div>Estado: <span id="status">Inactivo</span></div>
    <div style="margin-top:6px"><button id="startBtn">Iniciar Cámara</button></div>
    <hr style="margin: 8px 0;">
    <p>Ajuste Fino de Flexión (Prueba con la tecla 2 o 3 si dedos se doblan mal):</p>
    <div style="font-weight: bold;">Vector Ref.: <span id="ref-vector">Y+ (0, 1, 0)</span></div>
  </div>

  <a-scene background="color: #000"> 
    <a-assets>
      <a-asset-item id="handModel" src="hand.glb"></a-asset-item>
    </a-assets>

    <a-entity light="type: ambient; intensity: 1"></a-entity>
    <a-entity light="type: directional; intensity: 0.6" position="0 2 2"></a-entity>
    <a-entity camera position="0 0 0"></a-entity>

    <a-entity 
        id="handEntity" 
        hand-control 
        gltf-model="#handModel" 
        position="0 0 -1.0" 
        rotation="0 180 0" 
        scale="2.0 2.0 2.0">
    </a-entity>
  </a-scene>

<script>
const videoElement = document.getElementById('videoElement');
const overlay = document.getElementById('overlayCanvas');
const overlayCtx = overlay.getContext('2d');
const statusEl = document.getElementById('status');
const startBtn = document.getElementById('startBtn');
const handEntity = document.getElementById('handEntity');
const refVectorEl = document.getElementById('ref-vector');

let cameraInstance = null; 
let refVectorOption = 0; 
const hands = new Hands({
  locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
});
hands.setOptions({
  maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.6, minTrackingConfidence: 0.6
});
hands.onResults(onHandsResults);

startBtn.addEventListener('click', async () => {
  if (cameraInstance) return;
  statusEl.textContent = 'Iniciando...';
 
  try {
    const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 640, height: 480 } });
    videoElement.srcObject = stream;
   
    videoElement.onloadedmetadata = () => {
      videoElement.play();
      overlay.width = videoElement.videoWidth;
      overlay.height = videoElement.videoHeight;
      cameraInstance = new Camera(videoElement, {
        onFrame: async () => { await hands.send({image: videoElement}); },
        width: 640, height: 480
      });
      cameraInstance.start();
      statusEl.textContent = '¡Activo! (Mueve la mano)';
      startBtn.style.display = 'none';
      setupRefVectorControls();
    };
  } catch (error) {
    console.error("Error al acceder a la cámara:", error);
    statusEl.textContent = 'Error de cámara.';
  }
});

function setupRefVectorControls() {
    document.addEventListener('keydown', (e) => {
        if (e.key === '1') refVectorOption = 0;
        else if (e.key === '2') refVectorOption = 1;
        else if (e.key === '3') refVectorOption = 2;
       
        const vectors = ['Y+ (0, 1, 0)', 'X+ (1, 0, 0)', 'Z+ (0, 0, 1)'];
        refVectorEl.textContent = vectors[refVectorOption];
    });
}

// --- Componente de A-Frame (Posicionamiento y Animación) ---
AFRAME.registerComponent('hand-control', {
  init: function(){
    this.bones = {};
    this.basePose = {}; 
   
    this.invert = {x: -1, y: -1, z: -1}; 
    this.smoothFactor = 0.15; 
    this.lastLandmarks = null; 
    this.scaleFactor = 1.0;

    // Mapas de Configuración (Estables)
    this.flexionLimits = {
        'thumb000': {min: -0.1, max: 1.0}, 'thumb001': {min: -0.1, max: 1.1}, 'thumb002': {min: -0.1, max: 1.3},
        'index001': {min: -0.1, max: 1.5}, 'index002': {min: -0.1, max: 1.5},
        'middle001': {min: -0.1, max: 1.5}, 'middle002': {min: -0.1, max: 1.5},
        'ring001': {min: -0.1, max: 1.5}, 'ring002': {min: -0.1, max: 1.5},
        'pinky001': {min: -0.1, max: 1.5}, 'pinky002': {min: -0.1, max: 1.5},
    };
    this.abductionLimits = {
        'thumb000': {min: -0.6, max: 0.6}, 'thumb001': {min: -0.2, max: 0.2}, 'thumb002': {min: -0.2, max: 0.2},
        'index001': {min: -0.2, max: 0.2}, 'middle001': {min: -0.1, max: 0.1}, 'ring001': {min: -0.2, max: 0.2},
        'pinky001': {min: -0.25, max: 0.25}, 
    };
    this.flexionInfluence = {
        'thumb000': 0.6, 'thumb001': 0.6, 'thumb002': 0.6, 
        'index001': 0.45, 'index002': 0.45,
        'middle001': 0.45, 'middle002': 0.45,
        'ring001': 0.4, 'ring002': 0.4,
        'pinky001': 0.45, 'pinky002': 0.45, 
    };

    // === CAMBIO 36: Offsets del Pulgar (Punto Medio Fuerte) ===
    // 'z' es flexión ("abajo"), 'x' es abducción ("curvo")
    // Tus valores (-0.35) eran muy débiles. Mis valores (-0.8) eran muy fuertes.
    // ¡Probemos un punto medio fuerte para enderezarlo!
    this.poseOffsets = {
        'thumb000': { z: -0.6, x: -0.3 }, 
        'thumb001': { z: -0.5, x: -0.2 }, 
        'thumb002': { z: -0.4, x: -0.1 }
    };
    // === FIN DEL CAMBIO 36 ===


    this.el.addEventListener('model-loaded', () => {
      const obj = this.el.getObject3D('mesh');
      if (!obj) { console.warn('No mesh'); return; }
     
      obj.traverse(node => { 
        if (node.isBone) {
          this.bones[node.name] = node;
          this.basePose[node.name] = node.quaternion.clone(); 

          // Aplicar Compensación UNA SOLA VEZ
          if (this.poseOffsets[node.name]) {
            const offset = this.poseOffsets[node.name];
            const offsetEuler = new THREE.Euler(
              offset.x || 0,
              offset.y || 0,
              offset.z || 0,
              'YXZ'
            );
            const qOffset = new THREE.Quaternion().setFromEuler(offsetEuler);
            this.basePose[node.name].premultiply(qOffset);
          }
        } 
      });
      this.ready = true;
    });
  },
 
  tick: function(){
    if (!this.ready || !this.lastLandmarks) return; 
    const landmarks = this.lastLandmarks;
    this.applyLandmarksToBones(landmarks);
  },

  getRefVector: function() {
      if (refVectorOption === 1) return new THREE.Vector3(1, 0, 0); 
      if (refVectorOption === 2) return new THREE.Vector3(0, 0, 1); 
      return new THREE.Vector3(0, 1, 0); 
  },

  applyLandmarksToBones: function(landmarks) {
    const { bones, basePose, invert, smoothFactor, scaleFactor, flexionLimits, abductionLimits, flexionInfluence } = this;
    const ref = this.getRefVector(); 

    const fingerMap = [
      ['thumb000', 1, 2], ['thumb001', 2, 3], ['thumb002', 3, 4],
      ['index001', 6, 7], ['index002', 7, 8],
      ['middle001', 10, 11], ['middle002', 11, 12],
      ['ring001', 14, 15], ['ring002', 15, 16],
      ['pinky001', 18, 19], ['pinky002', 19, 20]
    ];
   
    const alpha = Math.max(0.02, smoothFactor); 

    // 1. Muñeca (Bone)
    if (bones['Bone'] && landmarks[0] && landmarks[9]) {
      const v0 = new THREE.Vector3(landmarks[0].x * invert.x, landmarks[0].y * invert.y, landmarks[0].z * invert.z);
      const v9 = new THREE.Vector3(landmarks[9].x * invert.x, landmarks[9].y * invert.y, landmarks[9].z * invert.z);
      const dirW = new THREE.Vector3().subVectors(v9, v0).normalize();
      const qDeltaW = new THREE.Quaternion().setFromUnitVectors(ref, dirW);
      const influenceW = Math.min(1, scaleFactor * 0.25); 
      const qApplyW = new THREE.Quaternion().slerpQuaternions(new THREE.Quaternion(), qDeltaW, influenceW);
      const base = basePose['Bone'] || bones['Bone'].quaternion.clone();
      let desired = base.clone().multiply(qApplyW);
      bones['Bone'].quaternion.slerp(desired, alpha);
    }

    // 2. Dedos (Lógica de animación)
    for (const [name, a, b] of fingerMap) {
      const bone = bones[name];
      if (!bone) continue;
      if (!landmarks[a] || !landmarks[b]) continue;

      const p1 = new THREE.Vector3(landmarks[a].x * invert.x, landmarks[a].y * invert.y, landmarks[a].z * invert.z);
      const p2 = new THREE.Vector3(landmarks[b].x * invert.x, landmarks[b].y * invert.y, landmarks[b].z * invert.z);
      
      let dir = new THREE.Vector3().subVectors(p2, p1); 
      if (dir.lengthSq() < 1e-6) continue;
      dir.normalize();

      const qDelta = new THREE.Quaternion().setFromUnitVectors(ref, dir);

      if (!name.includes('thumb')) {
          qDelta.invert();
      }

      const euler = new THREE.Euler().setFromQuaternion(qDelta, 'YXZ');

      let flexAxis = 'x';
      let abductAxis = 'z';

      if (name.includes('thumb')) {
          flexAxis = 'z';
          abductAxis = 'x';
      }

      const currentFlexionInfluence = flexionInfluence[name] !== undefined ? flexionInfluence[name] : 0.4;
      euler[flexAxis] *= currentFlexionInfluence; 

      if (flexionLimits[name]) {
          euler[flexAxis] = Math.max(flexionLimits[name].min, Math.min(flexionLimits[name].max, euler[flexAxis]));
      }
      if (abductionLimits[name]) {
          euler[abductAxis] = Math.max(abductionLimits[name].min, Math.min(abductionLimits[name].max, euler[abductAxis]));
      }
      
      euler.y = 0; 

      const qFinal = new THREE.Quaternion().setFromEuler(euler);
      const baseQ = basePose[name] ? basePose[name].clone() : bone.quaternion.clone();
      const desiredQ = baseQ.clone().multiply(qFinal);

      bone.quaternion.slerp(desiredQ, alpha); 
    }
  }
});


// --- Procesar Resultados de MediaPipe con Corrección de Espejo ---
function onHandsResults(results){
  overlayCtx.clearRect(0,0,overlay.width,overlay.height);
 
  // CORRECCIÓN DE ESPEJO
  overlayCtx.save();
  overlayCtx.translate(overlay.width, 0); 
  overlayCtx.scale(-1, 1); 
  overlayCtx.drawImage(results.image, 0, 0, overlay.width, overlay.height);
  overlayCtx.restore();
 
  if (results.multiHandLandmarks?.length > 0){
    const lm = results.multiHandLandmarks[0];
   
    if (videoElement.readyState >= 2) {
      for (let i=0;i<lm.length;i++){
        const x = (1 - lm[i].x) * overlay.width;
        const y = lm[i].y * overlay.height;
        overlayCtx.beginPath(); overlayCtx.arc(x,y,3,0,2*Math.PI);
        overlayCtx.fillStyle='red'; overlayCtx.fill();
      }
    }

    const comp = handEntity.components['hand-control'];
    if (comp) comp.lastLandmarks = lm.map(p=>({x:p.x, y:p.y, z:p.z}));
  } else {
    const comp = handEntity.components['hand-control'];
    if (comp) comp.lastLandmarks = null;
  }
}
</script>
</body>
</html>  
